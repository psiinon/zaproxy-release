/*
 * Zed Attack Proxy (ZAP) and its related class files.
 * 
 * ZAP is an HTTP/HTTPS proxy for assessing web application security.
 * 
 * Copyright 2010 psiinon@gmail.com
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); 
 * you may not use this file except in compliance with the License. 
 * You may obtain a copy of the License at 
 * 
 *   http://www.apache.org/licenses/LICENSE-2.0 
 *   
 * Unless required by applicable law or agreed to in writing, software 
 * distributed under the License is distributed on an "AS IS" BASIS, 
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
 * See the License for the specific language governing permissions and 
 * limitations under the License. 
 */
package org.zaproxy.zap.extension.websocket.ui;

import java.sql.CallableStatement;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

import org.parosproxy.paros.db.AbstractTable;
import org.parosproxy.paros.network.HttpMalformedHeaderException;
import org.zaproxy.zap.extension.websocket.WebSocketMessage;

/**
 * Manages writing and reading messages to the database.
 * TODO: Not used so far! For now all messages are held as objects in memory. 
 */
public class WebSocketTable extends AbstractTable {

	private static final String TABLE_WEBSOCKET = "WEBSOCKET";
	private static final String TABLE_WEBSOCKET_WEBSOCKETID = "WEBSOCKETID";
	private static final String TABLE_WEBSOCKET_HOST = "HOST";
	private static final String TABLE_WEBSOCKET_CHANNEL = "CHANNEL";

	private static final String TABLE_MESSAGE = "WEBSOCKET_MESSAGE";
    private static final String TABLE_MESSAGE_MESSAGEID = "MESSAGEID";
    private static final String TABLE_MESSAGE_WEBSOCKETID = "WEBSOCKETID";
    private static final String TABLE_MESSAGE_PAYLOAD = "PAYLOAD";
    
    private PreparedStatement psReadMessageByHost = null;
    private PreparedStatement psInsertChannel = null;
    private CallableStatement psInsertMessage = null;

    /**
     * Create tables if not already available
     */
    @Override
    protected void reconnect(Connection conn) throws SQLException {
    	ResultSet rs = conn.getMetaData().getTables(null, null, TABLE_WEBSOCKET, null);
        if (!rs.next()) {
			// need to create the table
			PreparedStatement stmt = conn
					.prepareStatement("CREATE cached TABLE "
							+ TABLE_WEBSOCKET
							+ "("
							+ TABLE_WEBSOCKET_WEBSOCKETID
							+ " bigint generated by default as identity (start with 1),"
							+ TABLE_WEBSOCKET_HOST 
							+ " varchar not null,"
							+ TABLE_WEBSOCKET_CHANNEL
							+ " bigint not null)");
			stmt.execute();
			stmt.close();
			
			stmt = conn.prepareStatement("CREATE cached TABLE "
							+ TABLE_MESSAGE
							+ "("
							+ TABLE_MESSAGE_MESSAGEID
							+ " bigint generated by default as identity (start with 1),"
							+ TABLE_MESSAGE_WEBSOCKETID
							+ " bigint not null,"
							+ TABLE_MESSAGE_PAYLOAD
							+ " varchar not null)");
			stmt.execute();
			stmt.close();
		}
        rs.close();

		psReadMessageByHost = conn.prepareStatement("SELECT * FROM "
				+ TABLE_MESSAGE + " JOIN " + TABLE_WEBSOCKET + " ON "
				+ TABLE_MESSAGE + "." + TABLE_MESSAGE_WEBSOCKETID + "="
				+ TABLE_WEBSOCKET + "." + TABLE_WEBSOCKET_WEBSOCKETID
				+ " WHERE " + TABLE_WEBSOCKET + "." + TABLE_WEBSOCKET_CHANNEL
				+ "=? ORDER BY " + TABLE_MESSAGE + "."
				+ TABLE_MESSAGE_MESSAGEID);

		psInsertChannel = conn.prepareStatement("INSERT INTO "
				+ TABLE_WEBSOCKET + "(" + TABLE_WEBSOCKET_WEBSOCKETID + ","
				+ TABLE_WEBSOCKET_HOST + "," + TABLE_WEBSOCKET_CHANNEL
				+ ") VALUES (?, ?, ?)");
		
		psInsertMessage = conn.prepareCall("INSERT INTO "
				+ TABLE_MESSAGE + "(" + TABLE_MESSAGE_MESSAGEID + ","
				+ TABLE_MESSAGE_WEBSOCKETID + "," + TABLE_MESSAGE_PAYLOAD
				+ ") VALUES (?, ?, ?)");
    }
    
    /**
     * Get messages.
     * 
     * @param host
     * @return
     * @throws HttpMalformedHeaderException
     * @throws SQLException
     */
	public synchronized List<WebSocketMessage> readMessages(String host) throws HttpMalformedHeaderException, SQLException {
	    psReadMessageByHost.setString(1, host);
	    psReadMessageByHost.execute();
		ResultSet rs = psReadMessageByHost.getResultSet();
		
		List<WebSocketMessage> messages = null;
		
		try {
			messages = build(rs);
		} finally {
			rs.close();
		}

		return messages;
	}
	
	/**
	 * 
	 * @param rs
	 * @return
	 * @throws HttpMalformedHeaderException
	 * @throws SQLException
	 */
	private List<WebSocketMessage> build(ResultSet rs) throws HttpMalformedHeaderException, SQLException {
		List<WebSocketMessage> messages = new ArrayList<WebSocketMessage>();
		try {
			if (rs.next()) {
//				messages.add(new WebSocketProxyV13.WebSocketMessageV13(rs.getBytes(TABLE_MESSAGE_PAYLOAD)));
			}
		} finally {
			rs.close();
		}
		
		return messages;
	}

	/**
	 * 
	 * @param host
	 * @param channelId
	 * @param message
	 * @return
	 * @throws HttpMalformedHeaderException
	 * @throws SQLException
	 */
	public synchronized void write(String host, int channelId, WebSocketMessage message) throws SQLException {	    
	    write(host, channelId, message.getPayload());	    
	}
	
	private synchronized void write(String host, int channelId, byte[] payload) throws SQLException {
		psInsertMessage.setBytes(1, payload);
        psInsertMessage.executeUpdate();
	}

}
