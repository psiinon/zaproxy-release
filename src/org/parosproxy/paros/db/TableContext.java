/*
 * Zed Attack Proxy (ZAP) and its related class files.
 * 
 * ZAP is an HTTP/HTTPS proxy for assessing web application security.
 * 
 * Copyright 2012 The OWASP ZAP Development Team
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); 
 * you may not use this file except in compliance with the License. 
 * You may obtain a copy of the License at 
 * 
 *   http://www.apache.org/licenses/LICENSE-2.0 
 *   
 * Unless required by applicable law or agreed to in writing, software 
 * distributed under the License is distributed on an "AS IS" BASIS, 
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
 * See the License for the specific language governing permissions and 
 * limitations under the License. 
 */

package org.parosproxy.paros.db;

import java.sql.CallableStatement;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

public class TableContext extends AbstractTable {
    
    private static final String TABLE_NAME = "CONTEXT_DATA";
    
    private static final String DATAID	= "DATAID";
    private static final String CONTEXTID	= "CONTEXTID";
    private static final String TYPE	= "TYPE";
    private static final String DATA	= "DATA";
    
    private PreparedStatement psRead = null;
    private PreparedStatement psInsert = null;
    private CallableStatement psGetIdLastInsert = null;
    private PreparedStatement psGetAllData = null;
    private PreparedStatement psGetAllDataForContext = null;
    private PreparedStatement psGetAllDataForContextAndType = null;
    private PreparedStatement psDeleteData = null;
    private PreparedStatement psDeleteAllDataForContextAndType = null;

    public TableContext() {
        
    }
        
    @Override
    protected void reconnect(Connection conn) throws SQLException {
        
        if (!DbUtils.hasTable(conn, TABLE_NAME)) {
            // Need to create the table
            DbUtils.executeAndClose(
                    conn.prepareStatement("CREATE cached TABLE CONTEXT_DATA (dataid bigint generated by default as identity (start with 1), contextId int not null, type int not null, data varchar(8192) default '')"));
        }

        psRead	= conn.prepareStatement("SELECT * FROM CONTEXT_DATA WHERE " + DATAID + " = ?");
        psInsert = conn.prepareStatement("INSERT INTO CONTEXT_DATA (" + CONTEXTID + "," + TYPE + "," + DATA + ") VALUES (?, ?, ?)");
        psGetIdLastInsert = conn.prepareCall("CALL IDENTITY();");

        psDeleteData = conn.prepareStatement("DELETE FROM CONTEXT_DATA WHERE " + CONTEXTID + " = ? AND " + TYPE + " = ? AND " + DATA + " = ?");
        psDeleteAllDataForContextAndType = conn.prepareStatement("DELETE FROM CONTEXT_DATA WHERE " + CONTEXTID + " = ? AND " + TYPE + " = ?");

        psGetAllData = conn.prepareStatement("SELECT * FROM CONTEXT_DATA");
        psGetAllDataForContext = conn.prepareStatement("SELECT * FROM CONTEXT_DATA WHERE " + CONTEXTID + " = ?");
        psGetAllDataForContextAndType = conn.prepareStatement("SELECT * FROM CONTEXT_DATA WHERE " + CONTEXTID + " = ? AND " + TYPE + " = ?");
    }
  
	public synchronized RecordContext read(long dataId) throws SQLException {
		psRead.setLong(1, dataId);
		
		ResultSet rs = psRead.executeQuery();
		RecordContext result = build(rs);
		rs.close();
		return result;
	}
	
    public synchronized RecordContext insert(int contextId, int type, String url) throws SQLException {
        psInsert.setInt(1, contextId);
        psInsert.setInt(2, type);
        psInsert.setString(3, url);
        psInsert.executeUpdate();
        
		ResultSet rs = psGetIdLastInsert.executeQuery();
		rs.next();
		long id = rs.getLong(1);
		rs.close();
		return read(id);
		
    }
    
    public synchronized void delete(int contextId, int type, String data) throws SQLException {
    	psDeleteData.setInt(1, contextId);
    	psDeleteData.setInt(2, type);
    	psDeleteData.setString(3, data);
    	psDeleteData.executeUpdate();
    }
    
    public synchronized void deleteAllDataForContextAndType(int contextId, int type) throws SQLException {
    	psDeleteAllDataForContextAndType.setInt(1, contextId);
    	psDeleteAllDataForContextAndType.setInt(2, type);
    	psDeleteAllDataForContextAndType.executeUpdate();
    }
    

    public List<RecordContext> getAllData () throws SQLException {
    	List<RecordContext> result = new ArrayList<RecordContext>();
    	ResultSet rs = psGetAllData.executeQuery();
    	while (rs.next()) {
    		result.add(new RecordContext(rs.getLong(DATAID), rs.getInt(CONTEXTID), rs.getInt(TYPE), rs.getString(DATA)));
    	}
    	rs.close();
    	
    	return result;
    }
                
    public List<RecordContext> getDataForContext (int contextId) throws SQLException {
    	List<RecordContext> result = new ArrayList<RecordContext>();
    	psGetAllDataForContext.setInt(1, contextId);
    	ResultSet rs = psGetAllDataForContext.executeQuery();
    	while (rs.next()) {
    		result.add(new RecordContext(rs.getLong(DATAID), rs.getInt(CONTEXTID), rs.getInt(TYPE), rs.getString(DATA)));
    	}
    	rs.close();
    	
    	return result;
    }
                
    public List<RecordContext> getDataForContextAndType (int contextId, int type) throws SQLException {
    	List<RecordContext> result = new ArrayList<RecordContext>();
    	psGetAllDataForContextAndType.setInt(1, contextId);
    	psGetAllDataForContextAndType.setInt(2, type);
    	ResultSet rs = psGetAllDataForContextAndType.executeQuery();
    	while (rs.next()) {
    		result.add(new RecordContext(rs.getLong(DATAID), rs.getInt(CONTEXTID), rs.getInt(TYPE), rs.getString(DATA)));
    	}
    	rs.close();
    	
    	return result;
    }
                
    private RecordContext build(ResultSet rs) throws SQLException {
        RecordContext rt = null;
        if (rs.next()) {
            rt = new RecordContext(rs.getLong(DATAID), rs.getInt(CONTEXTID), rs.getInt(TYPE), rs.getString(DATA));            
        }
        return rt;
        
    }

	public void setData(int contextId, int type, List<String> dataList) throws SQLException {
		this.deleteAllDataForContextAndType(contextId, type);
		for (String data : dataList) {
			this.insert(contextId, type, data);
		}
	}    
}
